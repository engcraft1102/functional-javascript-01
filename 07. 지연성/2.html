<script src="../lib/fx.js"></script>

<!--
  # 이터러블 중심 프로그래밍에서의 지연 평가 (Lazy Evaluation)
  - 제때 계산법
  - 느긋한 계산법
  - 제너레이터/이터레이터 프로토콜을 기반으로 구현
 -->

<!--
   L.map
  -->

<script>
  L.map = function* (f, iter) {
    for (const a of iter) yield f(a)
  }
  var it = L.map((a) => a + 10, [1, 2, 3])
  log(it.next())
  log(it.next())
  log(it.next())
</script>

<!--
   L.filter
  -->
<script>
  L.filter = function* (f, iter) {
    for (const a of iter) if (f(a)) yield a
  }
  var it = L.filter((a) => a % 2, [1, 2, 3, 4])
  log(it.next())
  log(it.next())
  log(it.next())
  console.clear()
</script>

<!--
  range, map, filter, take, reduce 중첩 사용
 -->

<script>
  go(
    range(10),
    map((n) => n + 10),
    filter((n) => n % 2),
    take(2),
    log
  )
</script>

<!--
  L.range, L.map, L.filter, take, reduce 중첩 사용
 -->

<script>
  L.range = function* (l) {
    let i = -1
    while (++i < l) {
      yield i
    }
  }

  L.map = curry(function* (f, iter) {
    for (const a of iter) yield f(a)
  })

  L.filter = curry(function* (f, iter) {
    for (const a of iter) if (f(a)) yield a
  })

  go(
    L.range(10),
    L.map((n) => n + 10),
    L.filter((n) => n % 2),
    take(2),
    log
  )
</script>
